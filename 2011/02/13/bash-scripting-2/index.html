<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
    










    







<script defer language="javascript" type="text/javascript" src="/js/bundle.min.145453261a7755f5042a854c4213501d215a8fbe34c08d181c40f803f1315e74.js"></script>






    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    <link rel="icon" href=/favicon.png>

    
    





  





  
  
  


<!-- Open Graph image and Twitter Card metadata -->

<title itemprop="name">Alexandre Mulatinho - Bash Scripting</title>
<meta property="og:title" content=Alexandre&#32;Mulatinho&#32;-&#32;Bash&#32;Scripting />
<meta name="twitter:title" content=Alexandre&#32;Mulatinho&#32;-&#32;Bash&#32;Scripting />
<meta itemprop="name" content=Alexandre&#32;Mulatinho&#32;-&#32;Bash&#32;Scripting />
<meta name="application-name" content=Alexandre&#32;Mulatinho&#32;-&#32;Bash&#32;Scripting />
<meta property="og:site_name" content="Alexandre Mulatinho Blog" />


<meta name="description" content="" />
<meta itemprop="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />


<base href="https://mulatinho.net/2011/02/13/bash-scripting-2/" />
<link rel="canonical" href="https://mulatinho.net/2011/02/13/bash-scripting-2/" itemprop="url" />
<meta name="url" content="https://mulatinho.net/2011/02/13/bash-scripting-2/" />
<meta name="twitter:url" content="https://mulatinho.net/2011/02/13/bash-scripting-2/" />
<meta property="og:url" content="https://mulatinho.net/2011/02/13/bash-scripting-2/" />


<meta property="og:updated_time" content="2011-02-13T21:39:54Z" />


<link rel="sitemap" type="application/xml" title="Sitemap" href='https://mulatinho.net/sitemap.xml' />

<meta name="robots" content="index,follow" />
<meta name="googlebot" content="index,follow" />



<meta property="fb:admins" content="" />


<meta name="apple-mobile-web-app-title" content="Alexandre Mulatinho Blog" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />






<meta name="generator" content="Hugo 0.140.2">


    
    

<link type="text/css" rel="stylesheet" href="/css/bundle.min.94a339836f89f0d25f31980cb6b0631da21e20af128308747ce44e0525eb16ef.css">


    
    <style>
    body {
        --sidebar-bg-color: #202020;
        --sidebar-img-border-color: #515151;
        --sidebar-p-color: #909090;
        --sidebar-h1-color: #FFF;
        --sidebar-a-color: #FFF;
        --sidebar-socials-color: #FFF;
        --text-color: #222;
        --bkg-color: #FAF9F6;
        --post-title-color: #303030;
        --list-color: #5A5A5A;
        --link-color: #268BD2;
        --date-color: #515151;
        --table-border-color: #E5E5E5;
        --table-stripe-color: #F9F9F9;
        --code-color: #000;
        --code-background-color: #E5E5E5;
        --code-block-color: #FFF;
        --code-block-background-color: #272822;
        --moon-sun-color: #FFF;
        --moon-sun-background-color: #515151;
    }
    body.dark-theme {
        --text-color: #EEE;
        --bkg-color: #121212;
        --post-title-color: #DBE2E9;
        --list-color: #9D9D9D;
        --link-color: #268BD2;
        --date-color: #9A9A9A;
        --table-border-color: #515151;
        --table-stripe-color: #202020;
        --code-color: #FFF;
        --code-background-color: #515151;
        --code-block-color: #FFF;
        --code-block-background-color: #272822;
    }
    body {
        background-color: var(--bkg-color);
    }
</style>

</head>

    <body class="dark-theme">
        <div class="wrapper">
            <aside class="sidebar">
    <div class="container sidebar-sticky">
        <div class="light-dark" align="right">
    <button class="btn-light-dark" title="Toggle light/dark mode">
        <svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M6 .278a.768.768 0 0 1 .08.858a7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277c.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316a.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71C0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"/>
        </svg>
        <svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16">
            <path fill="currentColor" d="M8 12a4 4 0 1 0 0-8a4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.415a.5.5 0 1 1-.707-.708l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .708z"/>
        </svg>
    </button>
</div>

        <div class="sidebar-about">
    <h1 class="brand">
        
        
            <a href="https://mulatinho.net/">
                <h1>Alexandre Mulatinho</h1>
            </a>
        
    </h1>
    <p class="lead">
    the home of a Brazilian software engineer
    </p>
</div>

        <center>

    <a target="_blank" class="social" title="GitHub" href="https://github.com/mulatinho">
        <svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24">
            <path fill="currentColor" d="M18.88 1.099C18.147.366 17.265 0 16.233 0H3.746C2.714 0 1.832.366 1.099 1.099C.366 1.832 0 2.714 0 3.746v12.487c0 1.032.366 1.914 1.099 2.647c.733.733 1.615 1.099 2.647 1.099H6.66c.19 0 .333-.007.429-.02a.504.504 0 0 0 .286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555 0 0 1-.904-.091a2.026 2.026 0 0 1-.872-.39a1.651 1.651 0 0 1-.572-.8l-.13-.3a3.25 3.25 0 0 0-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956 0 0 1-.17-.156a.723.723 0 0 1-.117-.182c-.026-.061-.004-.111.065-.15c.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1 0 0 1 .631.677c.2.355.44.626.722.813c.282.186.566.28.852.28c.286 0 .533-.022.742-.065a2.59 2.59 0 0 0 .585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907 0 0 1-1.333-.234a5.314 5.314 0 0 1-1.223-.507a3.5 3.5 0 0 1-1.047-.872c-.277-.347-.505-.802-.683-1.365c-.177-.564-.266-1.215-.266-1.952c0-1.049.342-1.942 1.027-2.68c-.32-.788-.29-1.673.091-2.652c.252-.079.625-.02 1.119.175c.494.195.856.362 1.086.5c.23.14.414.257.553.352a9.233 9.233 0 0 1 2.497-.338c.859 0 1.691.113 2.498.338l.494-.312a6.997 6.997 0 0 1 1.197-.572c.46-.174.81-.221 1.054-.143c.39.98.424 1.864.103 2.653c.685.737 1.028 1.63 1.028 2.68c0 .737-.089 1.39-.267 1.957c-.177.568-.407 1.023-.689 1.366a3.65 3.65 0 0 1-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9 0 0 1-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36 0 0 0 .208.189c.096.034.18.056.254.064c.074.01.18.013.318.013h2.914c1.032 0 1.914-.366 2.647-1.099c.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/>
        </svg>
    </a>



    <a target="_blank" class="social" title="LinkedIn" href="https://linkedin.com/in/mulatinho">
        <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 448 512">
            <path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5c0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7c-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5c67.2 0 79.7 44.3 79.7 101.9V416z"/>
        </svg>
    </a>















    <a target="_blank" class="social" title="RSS Feed" href="/posts/index.xml">
        <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 1280.000000 1280.000000">
            <g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)" fill="currentColor">
                <path d="M2295 11929 c-284 -12 -642 -45 -707 -65 -17 -5 -18 -63 -18 -1039 0 -569 4 -1036 8 -1039 5 -3 74 6 153 19 510 86 1168 95 1789 25 1348 -153 2602 -677 3670 -1531 385 -308 820 -744 1126 -1129 842 -1060 1362 -2313 1514 -3650 70 -621 61 -1279 -25 -1789 -13 -79 -22 -148 -19 -153 3 -4 471 -8 1039 -8 l1035 0 5 23 c51 225 85 942 67 1419 -23 605 -77 1044 -198 1617 -294 1400 -927 2734 -1823 3846 -1043 1295 -2364 2259 -3909 2854 -1158 447 -2451 656 -3707 600z"/>
                <path d="M2255 7845 c-269 -25 -620 -81 -667 -106 -17 -9 -18 -55 -18 -899 0 -706 3 -890 13 -890 6 0 66 18 132 41 130 44 288 79 467 105 154 21 577 30 749 15 1207 -107 2267 -823 2814 -1902 166 -327 268 -637 330 -1001 38 -227 48 -384 42 -662 -8 -348 -44 -590 -126 -831 -23 -66 -41 -126 -41 -132 0 -10 184 -13 890 -13 844 0 890 1 899 18 27 50 88 452 110 725 14 162 14 624 1 782 -59 703 -233 1323 -545 1945 -481 956 -1313 1788 -2270 2268 -620 310 -1239 483 -1940 542 -165 14 -669 10 -840 -5z"/>
                <path d="M2519 3815 c-391 -66 -725 -336 -868 -703 -79 -201 -96 -462 -45 -677 83 -344 338 -641 666 -774 116 -47 205 -69 330 -80 412 -39 811 153 1040 500 193 292 240 648 128 981 -135 403 -492 699 -914 757 -100 14 -241 12 -337 -4z"/>
            </g>
        </svg>
    </a>


    <a target="_blank" class="social" title="Email" href="mailto:alex@livredigital.com">
       <svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 485.211 485.211">
            <path fill="currentColor" d="M301.393,241.631L464.866,424.56H20.332l163.474-182.928l58.801,51.443L301.393,241.631z M462.174,60.651H23.027 l219.579,192.142L462.174,60.651z M324.225,221.67l160.986,180.151V80.792L324.225,221.67z M0,80.792v321.029L160.972,221.64 L0,80.792z"/>
       </svg>
    </a>



</center>

        <nav>
    <ul class="sidebar-nav">

        
        
        
	<center>
        
            

            <h2><a href="/"><b>About</b></a></h2>
        
	<center>
        
            

            <h2><a href="/docs/"><b>Docs</b></a></h2>
        
	<center>
        
            

            <h2><a href="/software/"><b>Softwares</b></a></h2>
        
	<center>
        
            

            <h2><a href="/posts/"><b>Posts</b></a></h2>
        
	</center>
    </ul>
</nav>

        <p class="footnote">
&copy; 2025 Alexandre Mulatinho Blog.<br/>
Powered by <a target="_blank" href="https://gohugo.io">Hugo</a> | themed with <a target="_blank" href="https://github.com/lukeorth/poison">poison</a>
</p>

  </div>
</aside>

            <main class="content container">
                <div class="post">
  <div class="info">
  <h1 class="post-title">
    <a href="https://mulatinho.net/2011/02/13/bash-scripting-2/">Bash Scripting</a>
  </h1>

  <div class="headline">
    <div>
      
        
          <span>mulatinho - </span>
        
      
      
      <time datetime=" 2011-02-13T21:39:54Z" class="post-date">
        February 13, 2011
      </time>
      
      <span> - </span>
      <span class="reading-time">
        
          
        

        <span>24 mins read</span>
      </span>
    </div>

    
  </div>

  
  

  
</div>

  <p>Texto de 2006, adicionado ao blog.</p>
<p>Há muito tempo eu escrevi uma introdução ao bash script e olhando ontem, resolvi fazer uma adaptação aqui no blog e colocar pra o pessoal ler, quem sabe alguém que esteja iniciando no mundo unix se interesse :-) Este texto contém uma visão introdutória sobre o que é uma shell e como a manipular, mas especificamente a Bourne-Again SHell (BASH).</p>
<p><strong>ÍNDICE</strong> <strong>1. - A SHELL NO LINUX</strong>
<strong>1.1 - O que é uma shell?</strong>
<strong>1.2 - Principais tarefas da shell.</strong> <strong>2. - O BÁSICO DO BÁSICO.</strong>
<strong>2.1 - Conectivos padrões e retornos lógicos.</strong>
<strong>2.2 - A matemática na shell.</strong>
<strong>2.3 - Tipos de parametros.</strong> <strong>3. - VARIÁVEIS</strong>
<strong>3.1 - Variáveis ambiente.</strong>
<strong>3.2 - Atribuindo comandos à variáveis.</strong> <strong>4. - ESTRUTURAS DE LOOP E CONDIÇÕES</strong>
<strong>4.1 - Usando loops.</strong>
<strong>4.2 - Fazendo condições.</strong> <strong>5. - AVANÇANDO</strong> <strong>5.1 - Redirecionando entrada/saída de dados.</strong>
<strong>5.2 - Usando comandos em background e adcionando interrupções.</strong>
<strong>5.3 - Alguns comandos: sed, cut, wc, od.</strong>
<strong>5.4 - Cores no terminal.</strong> <strong>6. - ARQUIVOS DE CONFIGURAÇÃO</strong>
<strong>6.1 - .bashrc</strong>
<strong>6.2 - .bash_history</strong></p>
<p>BIBLIOGRAFIA:
Programação Shell Linux, Júlio Cezar Neves, Brasport.
The GNU Bash Reference Manual
<a href="http://www.network-theory.co.uk/bash/manual/toc/" title="Linkification: http://www.network-theory.co.uk/bash/manual/toc/" target="_blank">http://www.network-theory.co.uk/bash/manual/toc/</a> <strong>1. A shell no Linux</strong></p>
<p>A shell está no Linux desde o início e serve justamente para executar os comandos com mais eficiência do que seriam executados se estivessem sem a organização que ela oferece. O Linux desde o início foi desenvolvido em partes que formam um todo utilizando um núcleo que chamamos de KERNEL, essas partes são pequenos ou grandes programas que utilizam chamadas do kernel para realizar a maioria de suas tarefas em conjunto ou separados.</p>
<p>Digamos que se quisessemos copiar um arquivo para outro usariamos algo como o comando cp ou se quisessemos apenas modificar seu nome usariamos o comando mv. Para que tudo fosse mais prático os seus desenvolvedores pensaram em algo que pudesse interpretar e unir com mais facilidade esses comandos/programas, foi aí que originou-se a shell com o intuito de organizar estes comandos, interpretando-os e também com uma poderosa linguagem de programação com o conjunto de seus programas. O sistema operacional UNIX e seus derivados como no nosso caso, o Linux, é composto por várias &ldquo;camadas&rdquo;. A mais interna de todas elas é a que chamamos de KERNEL ou núcleo, ele é responsável por interagir diretamente com o HARDWARE simplesmente fornecendo o controle total para que o resto do sistema funcione, por exemplo quando escrevemos algo em um arquivo ou mesmo quando estamos lendo, o KERNEL envia sinais para que o processador procure na trilha e no setor certo do disco onde está sendo gravado/lido certo dado que foi processado.</p>
<p>Os programas por sua vez quando são executados as vezes precisam que o usuário forneça dados como argumentos ou opções, no nosso terminal então precisamos de algo que entenda o que está sendo pedido e é finalmente aí onde entramos com a SHELL.</p>
<p><strong>1.1 O Que é uma shell?</strong></p>
<p>Pra começo de conversa, no momento em que você se loga no sistema você já está numa SHELL. A SHELL é um meio pelo qual o usuário entra com dados para o sistema fazendo com que o sistema identifique esses dados e os converta para o sistema operacional poder lê-los sem ter que resolvê-los, diminuindo assim o tempo que seria gasto se a SHELL não interpretasse esses dados e o deixasse para que o kernel também fosse resolvê-lo. Tendo em vista esses dados podemos dizer que a SHELL é uma ferramenta poderosa que usamos para interpretar nossos comandos antes de roda-los fazendo com que seja possível o uso de parametros, substituição de strings, modificação de variáveis ambiente, etc. Também vale ressaltar que a shell vem com uma linguagem poderosa, chamada shell script, que nos permite utilizar laços de condição e processamento de certos dados, principalmente os de entrada e saída.</p>
<p><strong>1.2 Principais tarefas da Shell.</strong></p>
<p>As principais tarefas da nossa shell são compreender e organizar a linha de comando que o usuário envia na entrada de dados, fazendo assim com que
os comandos executados rodem com mais performance e de um jeito muito mais estruturado, depois de feito isso a shell ordena de ESPAÇO em ESPAÇO cada comando e argumento enviado, procurando-os na variável $PATH que contém os caminhos onde o usuário em questão pode executar programas. A shell também é capaz de agir como um interpretador de linguagem estruturada, permitindo-nos fazer scripts com a mistura de comandos que o sistema nos fornece. Podemos resumir então estes processos desta forma:</p>
<ol>
<li>A shell pega os dados e os interpreta antes de serem executados.</li>
<li>Usa variáveis ambiente como o $PATH, que nos mostra os diretórios aos quais o usuário tem acesso para execução de comandos.</li>
<li>Processa como os dados vão sair e entrar corretamente (input/output).</li>
<li>A nível de programação ela executa laços, condições, etc.</li>
</ol>
<p><strong>2. O básico do básico.</strong></p>
<p>Este capítulo é chamado de básico do básico porque relaciona coisas bem iniciantes a nível de noções da shell no Linux, para obtermos uma visão
correta é preciso ter noção de como funciona alguns comandos do linux que estão diretamente ligados ao uso da nossa shell, por exemplo para listarmos
o conteúdo de um diretório não precisamos entrar nele para ver seus arquivos, basta que usemos o comando de listagem com o diretório como
parametro, por exemplo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ ls /home/alexandre/txtz/y0/
bash.txt  plantz.txt  provas.txt  userfile.txt
</code></pre><p>ou</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ cd /home/alexandre/txtz/y0
$ pwd
/home/alexandre/txtz/y0
$ ls
bash.txt  plantz.txt  provas.txt  userfile.txt
</code></pre><p>Como podemos ver isso tudo é muito básico mas é necessário ter uma idéia que estamos trabalhando com um interpretador de comandos que nos oferece além de qualidade para entender o que está sendo digitado também praticidade e velocidade. Vejamos como seria se eu quisesse me movimentar um diretório abaixo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ cd ..
$ pwd
/home/alexandre/txtz
$ ls -lh
-rw-r--r--    1 alexandr users        307k Dec 22  2003 focalinux.txt
drwxr-xr-x    2 alexandr users         200 Sep  3 12:01 y0
</code></pre><p>Vemos que descemos um diretório abaixo de onde estávamos usando o comando cd seguido de 2 pontos finais, a shell interpreta isso fazendo com que nós voltemos um diretório do orignal a qual estávamos. Uma observação interessante a se comentar é que o diretório y0 nada mais é do que um
arquivo assim como todos os diretórios do linux, a diferença é a flagzinha &rsquo;d&rsquo; na sua permissão.</p>
<p>Outra coisa que devemos observar é que como na matemática a shell da preferência a opções que estejam entre parenteses, por exemplo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ ls txtz/y0/
bash.txt  file.txt  plantz.txt  provas.txt  userfile.txt
$ pwd
/home/alexandre
$ ( cd txtz/y0/ ; cat file.txt )
voce esta me lendo! ohh :~
$ pwd
/home/alexandre
</code></pre><p>Ué ? por que eu não fui pro diretorio txtz/y0/ ? e como eu li o arquivo file.txt se ele estava dentro desse diretório e eu ainda continuo no $HOME
CALMA! Não foi nenhuma macumba.. o que aconteceu foi que a shell deu preferência ao comando entre parenteses, executou o comando em uma shell filho e retornou a shell normal matando a shell filho. Outro tipo de forma pra mostramos como o parenteses está em preferência com a shell é usando um comando qualquer entre parenteses:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ echo &#34;A versão do meu kernel é: $(uname -r)&#34;
A versão do meu kernel é: 2.4.26
</code></pre><p>Para saber como funciona essa interpretação de comandos nós temos que
voltar a coisas bem iniciais por isso chamamos essa parte de básico do
básico, imaginemos então:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ ls
eu.txt voce.txt nos.txt vos.txt eles.txt
</code></pre><p>Temos um comando simples &rsquo;ls&rsquo; que quando executado na shell
retorna os arquivos do diretorio em que estamos. Agora vejamos:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ ls e*
eu.txt eles.txt
</code></pre><p>Digitamos novamente o &rsquo;ls&rsquo; sendo que com um argumento, a primeira letra
&rsquo;e&rsquo; seguida de um ASTERISCO, a shell então retorna todos os arquivos do
diretório que contém a primeira letra que indicamos mais TODO O RESTO, que
é o que significa o asterisco. Vemos agora a utilidade das aspas no echo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ echo 1 2 3...    VOCE  EH ESTA  APRENDENDO  BASH
1 2 3... VOCE EH ESTA APRENDENDO BASH
$ echo &#34;1 2 3...    VOCE  EH ESTA  APRENDENDO  BASH&#34;
1 2 3...    VOCE  EH ESTA  APRENDENDO  BASH
</code></pre><p>OBS: Veja que a mudança ocorre na saída do texto quando usamos às aspas.</p>
<p>Resumindo, ela interpretou o comando antes de executa-lo, isso se faz
muito útil para que você as vezes não tenha que fazer vários comandos com
um objetivo só ou as vezes queira obter mais performance. Por exemplo no
caso de interagir com um ou mais comandos, deve-se usar conectivos.</p>
<p>2.1 Conectivos padrões e retornos lógicos.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">TABELA DE CONECTIVOS                       TABELA VERDADE
+-----------+---------------------------------+   +---+---+------+
| CONECTIVO | DESCRIÇÃO                       |   | A | B |A &amp;&amp; B|
+-----------+---------------------------------+   +---+---+------+
|     &amp;&amp;    | AND (E) lógico.                 |   | 0 | 0 |  0   |
|     ||    | DOUBLE PIPE (OU) lógico.        |   | 0 | 1 |  0   |
|     |     | PIPE (OU) lógico.               |   | 1 | 0 |  0   |
+-----------+---------------------------------+   | 1 | 1 |  1   |
</code></pre><pre tabindex="0"><code class="language-default" data-lang="default">$ df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda1             9.8G  2.9G  6.9G  29% /
/dev/hda4              14G  3.2G   10G  23% /mnt
$ echo $?
0
</code></pre><p>O duplo caracter $? (dólar,interrogação) retorna o valor do resultado do
comando digitado na entrada, fornecendo 0 se o comando retornar OK e 1 se
ele retornar com algum erro (observemos que é o inverso da tabela verdade
usada na lei de Boole). Com isso podemos usar os conectivos e colocar dois
comandos numa linha apenas, por exemplo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ cd /
$ echo &#34;Arquivos do diretório atual ($PWD):&#34; &amp;&amp; ls
Arquivos do diretório atual (/):
bin  boot  dev  etc  home  lib  mnt  opt  proc  root  sbin  tmp  usr  var
</code></pre><p>*OBS: Como o resultado do comando echo e do ls são 0 (e na tabela verdade
da shell o 0 representa LIGADO), indicando que eles retornaram VERDADEIRO
os dois comandos são colocados na tela. O $PWD é uma variável do sistema
que será explicada depois ;)</p>
<p>Então já podemos dizer que a tabela VERDADE da nossa shell ficaria da
forma inversa da tabela original da lei de Boole.</p>
<p>TABELA VERDADE DE EXECUÇÃO NA SHELL</p>
<pre tabindex="0"><code class="language-default" data-lang="default">+---+---+------+
| A | B | A&amp;&amp;B |          RETORNO:
+---+---+------+          --------
| 0 | 0 |  0   |          0 = OK.
| 0 | 1 |  1   |          1 = ERRO.
| 1 | 0 |  1   |
| 1 | 1 |  1   |
+---+---+------+
</code></pre><p>Ou seja, os dois comandos só seriam impressos na tela juntos se ambos os
termos fossem 0 quanto ao seu resultado. Agora vejamos se no primeiro
argumento o resultado fosse maior que ou igual a 1, e o próximo fosse 0
usando o AND condicional ficaria:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ ls /root &amp;&amp; echo &#34;Fim do /root&#34;
ls: /root: Permission denied
$ echo $?
1
</code></pre><p>*OBS: O 1° argumento retorna um numero diferente de 0 fazendo com que o
2° comando nao seja executado porque de acordo com a tabela verdade
do AND condicional o 2° comando só executado se houvesse uma verdade
lógica ou um retorno 0;.</p>
<p>Temos:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ ls /root
ls: /root: Permission denied
$ echo $?
1

$ echo &#34;Fim do /root&#34;
Fim do /root
$ echo $?
0
</code></pre><p>Então:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">!(1 &amp;&amp; 0) =&gt;; 1 (ERRO/DESLIGADO)
</code></pre><p>Já no caso do PIPE (|), a prioridade dos argumentos sempre estão do lado
direito(ou 2° argumento) é muito útil quando estamos lendo algo no console
quando o texto é muito grande e precisamos realizar pausas pra leitura:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ cat /usr/doc/Linux-HOWTOs/Bash-Prompt-HOWTO | grep PS1
</code></pre><p>O comando cat é executado fazendo com que todo o arquivo seja impresso na tela embora com uma diferença, todo o texto é enviado para o comando grep, que por sua vez procura por strings no arquivo e entrada retornando apenas as linhas que contenham o argumento passado no comando &lsquo;grep&rsquo; ;]</p>
<p><strong>2.2 A matemática da shell.</strong></p>
<p>Temos várias formas para realizarmos calculos matemáticos na shell,
podemos simplesmente usar o comando &rsquo;expr&rsquo; ou usar cálculos entre
parenteses com as definições de operadores da shell.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">TABELA DE OPERADORES
+-------+-----------------------------------------------+
| VALOR | SIGNIFICADO                                   |
+-------+-----------------------------------------------+
|   +   | Como na matemática, serve para somar números. |
|   -   | Também como na matemática, subtrair.          |
|   /   | Este é o operador para divisão de números.    |
|   *   | Operador de multiplicação.                    |
|   %   | Resto de uma divisão.                         |
| == != | Igual e diferente.                            |
| &lt;= &gt;= | Menor igual que, maior igual que.             |
+-------+-----------------------------------------------+
</code></pre><p>Podemos realizar operações usando o comando expr mais os números e que
tipo de operadores queremos para realizar cálculos, ou simplesmente usar o
echo $((CALCULO MATEMATICO)), onde dentro desses DOIS parenteses, faremos
o cálculo para ser armazenado ou impresso na tela. Exemplos:</p>
<p>Fazer a soma de 4 + 5:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ expr 4 + 5
9
</code></pre><p>A média aritmética de 20+15+10:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ echo $(( (20+15+10) / 3 ))
15
</code></pre><p>Multiplicar 3 por 5:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ expr 3 * 5
expr: syntax error
</code></pre><p>Ué!? O que houve de errado? bom, relembrando o início a shell interpreta os comandos antes de executa-los, ela entendeu o ASTERISCO como usamos anteriormente significando QUALQUER COISA, só que isso numa operação matemática não faz sentido. O que fazer então? temos que proteger o asterisco da shell pra dar prioridade ao operador e não a interpretação
que a shell faz do asterisco normal.</p>
<p>Novamente, protegendo o asterisco, multiplicando 3 por 5:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ expr 3 * 5
15
</code></pre><p>Há também outra forma de fazermos cálculos, usando a cálculadora padrão do GNU a bc. Como vimos, usando o PIPE odemos jogar uma informação no 2° argumento de um comando:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ echo &#34;(4 * 27) + 21&#34; | bc
129
</code></pre><p>Usamos às aspas para proteger o parenteses da shell e jogamos a operação
na calculadora bc que nos retorna o resultado rapidamente.</p>
<p>2.3 Tipos de parâmetros.</p>
<p>O uso de parametros é quase constante em uma linha de comando de uma
pessoa que esteja acostumada à shell, eles tornam tudo mais fácil e as
vezes se fazem extremamente necessários.</p>
<p>o&gt; parametro de substituição de comando</p>
<p>para a shell saber onde executar os comandos é necessário uma forma de
procura por programas para executar no sistema, a variável $PATH indica
onde o usuário em questão verá os diretorios separados por &lsquo;:&rsquo; do
sistema aos quais ele obterá acesso à comandos.</p>
<p>podemos utilizar um parametro para executar comandos na shell fazendo
com que seu output saia na tela ou seja armazenado em alguma variável,
a shell bash vai entender o que estiver entre os parenteses como um
comando de algum diretório do $PATH.</p>
<p>SINTAXE</p>
<p>$(COMANDO) =&gt; Abre uma subshell e executa o comando retornando a
shell pai e saindo da subshell.</p>
<p>ou</p>
<p>`comando` =&gt; Executa um comando normal do sistema.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ echo -e &#34;todays fortune:n $(fortune)&#34;
todays fortune:
&#34;All flesh is grass&#34;
-- Isiah
Smoke a friend today.

$ SYSTEM=`uname -s`
$ echo &#34;Sistema: $SYSTEM&#34;
Sistema: Linux
</code></pre><p>voce pediu pra a shell imprimir uma frase, seguida de um comando
&lsquo;fortune&rsquo; que faz parte de um pacote chamado bsdgames, ele é bem
interessante, é composto de milhares de frases e pensamentos de
filósofos, autores de livros, etc. já no segundo exemplo usamos uma
variável SYSTEM para armazenar o retorno do comando &lsquo;uname -s&rsquo; depois
imprimimos na tela.</p>
<p>o&gt; parametros com chaves</p>
<p>as vezes queremos nos referir a um nome de arquivo em vários tipos de
extensão, ou fazer coisas do tipo, para isso podemos ao inves de ter
que escrever toda a linha de comando repetidamente usamos as chaves.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ echo m{a,e,o}ngo          ou         $ ls *.{bz2,txt}
mango mengo mongo                      IAO-paper.txt focalinux.txt
gcc-3.3.tar.bz2 retlib.txt
</code></pre><p>evitamos ter que fazer repetições na linha de comando colocando as
sequencias necessarias entre chaves.</p>
<p>o&gt; outros parametros</p>
<p>podemos trocar strings de um parametro, declaramos ele desta forma:
${PARAMETRO/STRING/NEWSTRING} , onde STRING é a ocorrência que você
deseja modificar e o NEWSTRING é a nova string que vai ficar.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ STR=&#34;estou aprendendo a errar&#34;
$ echo ${STR/errar/viver}
estou aprendendo a viver
</code></pre><p>ou se quisessemos ver o tamanho de caracteres de uma string, fariamos
assim ${#STRING}, onde STRING seria a variavel ou palavra/frase.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ echo $STR
estou aprendendo a errar
$ echo ${#STR}
24
</code></pre><p>para pegarmos um argumento da linha de comando usamos o carácter
dólar seguido da ordem do seu argumento, exemplo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ ./comando arg1 arg2 arg3
$1 -&gt; arg1
$2 -&gt; arg2
$3 -&gt; arg2
</code></pre><p>3. Variáveis.</p>
<p>Uma coisa muito útil na shell é a possibilidade de armazenamento de
dados na memória, fazendo isso podemos atribuir à variaveis saídas de
comandos, calculos aritméticos e strings. Para setar uma variável na
shell basta fazer:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ A=1
$ B=HELLO
$ C=&#34;HELLO WORLD&#34;

$ echo $A $B $C
1 HELLO HELLO WORLD
</code></pre><p>Veja que dessa vez não usamos o DÓLAR para setar a variável A,B,C esse
dólar só vai ser colocado quando quisermos que a shell retorne o valor
da variável. Para remover a variável do sistema é só fazer:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ unset C
$ echo $C
</code></pre><p>3.1 Variáveis ambiente.</p>
<p>Há uma série de variáveis padrões definidas pela SHELL quando você se
loga nela, estas servem para organizar de forma mais eficiente tudo que
o usuário tem acesso, pode fazer e quer saber. Vamos ver algumas delas:</p>
<p>$HOME =&gt; Indica o diretório raiz do usuário que esta logado na shell.
$PATH =&gt; Diretórios aos quais o usuário tem acesso à comandos.
$PWD =&gt; Diretório onde o usuário se encontra.
$USER =&gt; Usuário logado na shell.</p>
<p>Para vermos todas elas usamos o comando &rsquo;export&rsquo; que serve também para
setar as variáveis ambiente na shell. Para ver todas:</p>
<p><strong>$ export</strong>
&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;.</p>
<p>Para setar:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ export VAR=&#34;Conteúdo&#34;
$ echo $VAR
Conteúdo
</code></pre><p>3.2 Atribuindo comandos à variáveis.</p>
<p>Podemos utilizar as variáveis também para armazenar saída de comandos
do sistema, para isso colocamos o comando entre crases, vejamos exemplos:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ cd txtz/y0/
$ pwd
/home/alexandre/txtz/y0
$ var=`ls`
$ echo $var
bash.txt file.txt plantz.txt provas.txt slides.txt userfile.txt
</code></pre><p>Entramos no diretório e setamos uma variável &lsquo;var&rsquo; com o valor da saída
do comano &rsquo;ls&rsquo;, depois imprimimos o valor com o comando echo.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ proc=`cat /proc/cpuinfo | grep &#34;model name&#34; | cut -d&#34; &#34; -f4-10`
$ echo &#34;PROCESSADOR: $proc&#34;
PROCESSADOR: Athlon(tm) XP 1700+
</code></pre><p><strong>4. Estrutura de loops e condições.</strong></p>
<p>Podemos elaborar processos repetidas vezes de acordo com a condição que
desejarmos, usando as estruturas de loop e condições começamos a falar de
shell script que nada mais é do que uma forma estruturada de organizar os
comandos do sistema utilizando tudo que aprendemos em conjunto(variáveis,
comandos, retornos de comandos, etc).
Há diferença entre eles é que os loops executam uma certa sequencia de
comandos digitados pelo programador até que aconteça algo que será
processado e de acordo com o tipo de loop, terminado ou continuado,
enquanto as condições esperam que o programa receba algo e de acordo com
um teste que foi previsto pelo programador anteriormente execute um bloco
de códigos ou não.
Para setar um arquivo como shell script deve-se coloca-lo com uma
permissão de execução, fazendo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ chmod +x arquivo
$ ./arquivo
</code></pre><p>Tendo em vista isto, temos também que entender que no shell script os
operadores para condições matemáticas tambem mudam, exemplo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">| OPERADOR | SIGNIFICADO                                 |
+----------+---------------------------------------------+
|   -lt    | less than (menor que).                      |
|   -le    | less or equal than (menor ou igual que).    |
|   -gt    | greater than (maior que).                   |
|   -ge    | greater or equal than (maior ou igual que). |
|   -eq    | equal than (igual que).                     |
|   -ne    | not equal (diferente de).                   |
+----------+---------------------------------------------+
</code></pre><p>Também é bom lembrar que num arquivo shell script, a primeira linha
deverá sempre ser a declaração da shell em que estamos programando:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">#!/bin/bash
</code></pre><p><strong>4.1 Usando loops.</strong></p>
<p>Os loops servem entre outras coisas para executar um bloco de códigos
até que um teste seja atingido, vejamos alguns tipos de loop:</p>
<p>o&gt; until</p>
<p>SINTAXE</p>
<pre tabindex="0"><code class="language-default" data-lang="default">until [ &#39;TESTE&#39; ] ; do
CÓDIGO....
done
</code></pre><p>O comando until serve para executar um laço até o seu TESTE retorne
um valor diferente diferente de 0 (ou seja, até que o teste seja falso)</p>
<pre tabindex="0"><code class="language-default" data-lang="default">#!/bin/bash
IN=10

until [ $IN -lt 4 ] ; do
echo &#34;LOOP: $IN&#34;
IN=`expr $IN - 2`
done

$ ./until
LOOP REVERSO: 10
LOOP REVERSO: 8
LOOP REVERSO: 6
LOOP REVERSO: 4
</code></pre><p>o&gt; while</p>
<p>SINTAXE</p>
<pre tabindex="0"><code class="language-default" data-lang="default">while [ &#39;TESTE&#39; ] ; do
CÓDIGO...
done
</code></pre><p>Fazendo o inverso do until, o comando while executa o CÓDIGO até que
o retorno de seu TESTE seja igual a 0 (ou seja verdadeiro), exemplo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">#!/bin/bash
IN=0

while [ $IN -lt 4 ] ; do
echo &#34;LOOP: $IN&#34;
IN=`expr $IN + 1`
done

$ ./while
LOOP: 0
LOOP: 1
LOOP: 2
LOOP: 3
</code></pre><p>o&gt; for</p>
<p>SINTAXE</p>
<pre tabindex="0"><code class="language-default" data-lang="default">for (( expr1 ; expr2; expr3 )) ; do
CÓDIGO...
done
</code></pre><p>Onde temos o primeiro modo de utilizar o for na shell, o expr1 é um valor que será atribuido à uma variável, o expr2 é um teste que será feito até que seu resultado seja verdadeiro, fazendo com que o bloco de código seja executado repitidamente e expr3 será o que será feito quando o teste for verdadeiro, poucos usam o for desta forma embora na minha opnião seja mais eficiente. Por exemplo:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">#!/bin/bash
for (( i=0 ; i&lt;5 ; i++ )); do
echo &#34;loop: $i&#34;
done

$ ./for
loop: 0
loop: 1
loop: 2
loop: 3
loop: 4
</code></pre><p>4.2 Fazendo condições.</p>
<p>É necessário fazer condições quando recebemos algo da entrada de um
usuário e queremos realizar um TESTE com esses dados para ver qual rumo
o programa deve tomar. Vamos usar dois tipos de comandos básicos para
execução de condições, são eles:</p>
<p>o&gt; if-then-else</p>
<p>SINTAXE</p>
<pre tabindex="0"><code class="language-default" data-lang="default">if [ &#39;TESTE&#39; ] ; then
CÓDIGO...
fi
</code></pre><p>Executa o TESTE, se ele for verdadeiro executa o bloco de CÓDIGO senão sai sem executar nada dentro do if.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">if [ &#39;TESTE&#39; ] ; then
CÓDIGO...
elif [ &#39;TESTEDOIS&#39; ] ; then
CÓDIGO DOIS...
fi
</code></pre><p>Executa o TESTE, aciona o bloco de CÓDIGO se o resultado do teste for verdadeiro.. depois executa o TESTEDOIS e se for verdadeiro ele executa o bloco de CÓDIGO DOIS.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">if [ &#39;TESTE&#39; ] ; then
CÓDIGO...
else
CÓDIGO DOIS...
then
</code></pre><p>Aqui ele executa o TESTE, entra no bloco de CÓDIGO se o resultado
do teste for verdadeiro, senão ele entre no bloco de CÓDIGO DOIS.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">#!/bin/bash
IN=$1

if [ &#34;$1&#34; == &#34;Mulher&#34; ] ; then
echo &#34;Olá senhorita :)~&#34;
elif [ &#34;$1&#34; == &#34;Homem&#34; ] ; then
echo &#34;Como vai meu bom homem?&#34;
else
echo &#34;Escolha sua opção sexual rapaz!&#34;
fi

$ ./ifthenelse
Escolha sua opção sexual rapaz!
$ ./ifthenelse Homem
Como vai meu bom homem?
$ ./ifthenelse Mulher
Ola senhorita :)~
</code></pre><p>o&gt; case</p>
<p>SINTAXE</p>
<pre tabindex="0"><code class="language-default" data-lang="default">case ARG in
PS1)
CÓDIGO
;;

PS2)
CÓDIGO DOIS
;;
esac
</code></pre><p>Aqui o teste ocorre em cima de ARG, o case explode várias possíveis alternativas que podem ser PS1, PS2, PS3, &hellip;, PSN. Uma boa função do case é poder fazer essas possibilidades usando meta-caracteres.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">#!/bin/bash
IN=$1

case $IN in
[a-c])
echo &#34;Tu és homem!&#34;
;;
[d-f])
echo &#34;Tu és mulher!&#34;
;;
[0-9])
echo &#34;Tá confuso?&#34;
;;
esac

$ ./case b
Tu és homem!
$ ./case 3
Tá confuso?
</code></pre><p>5. Avançando.</p>
<p>Nesta parte vamos começar a complicar mais um pouquinho pra descomplicar bem muito, hã? é isso mesmo, aqui vamos mostrar alguns comandos que a maioria nem chega perto mas que são úteis demais para um shell scripter.</p>
<p><strong>5.1 Redirecionando entrada/saída de dados.</strong></p>
<p>Podemos direcionar como os dados irão entrar e como irão sair em nossa shell usando operadores, para começarmos a fazer isso devemos lembrar os 3 tipos padrões de entrada/saída de dados, são eles:</p>
<p>(0 ou STDIN) =&gt; Standard Input (Entrada Padrão).
(1 ou STDOUT) =&gt; Standard Output (Saída Padrão).
(2 ou STDERR) =&gt; Standard Error (Saída de erro padrão).</p>
<p>Tendo em mente isso, usamos operadores para o redirecionamento que são parecidos com os símbolos da matemática:</p>
<p>| OP | SIGNIFICADO |
+&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+
| N&gt; | Onde N, é o valor da saída de dados (1 ou 2), fazendo com que |
| | o redirecionamento da saída seja feito há direita do operador. |
| &gt; | Envia os dados para arquivo, criando-o caso não existe ou |
| | apagando seu conteúdo anterior e adcionando novo, caso exista. |
| &gt;&gt; | Aqui há o redirecionamento de dados para o FINAL do arquivo |
| | caso exista, ou uma criação de arquivo, caso não exista. |
| &lt; | Setamos na shell que a entrada padrão não irá vir do teclado |
| | e sim do arquivo em questão. |
| &laquo; | Indicamos um LABEL para o começo de uma linha fazendo com que |
| | a linha só termine quando houver a proxima ocorrência do LABEL |
+&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ echo &#34;Ohh! voce me leu :~&#34; &gt; file.txt
$ cat file.txt
Ohh! voce me leu :~

$ echo &#34;Que trágico!&#34; &gt;&gt; file.txt
$ cat file.txt
Ohh! voce me leu :~
Que trágico!

$ tr e i &lt; file.txt
Ohh! voci mi liu :~
Qui trágico!

$ mount /dev/cdrom /mnt/cdrom 2&gt; error.txt
$ cat error.txt
mount: only root can do that
</code></pre><p><strong>5.2 Usando comandos em background e adcionando interrupções</strong></p>
<p>Podemos rodar comandos em modo background., que significaria mais ou
menos que executamos um comando deixando-o numa file de espera, então
ele em alguns programas que precisam de entrada de dados só irá
executar suas funções quando agente o chamar no sistema.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ vim file.txt &amp;
[1] 22956
Î   Î
`---|-------- 1 = First Job (Primeiro trabalho.)
&#39;--- 22956 = PID (Process ID).
</code></pre><p>Vêmos que ele carregou o programa numa subshell, mas não executou a sua função que era de editar o arquivo, para fazermos isso, digitamos</p>
<p>$ fg 1</p>
<p>E então o ID do processo em background sairá da subshell e virá para nossa shell principal, podemos fazer isso várias vezes. Outra coisa muito útil é que podemos adcionar interrupções ou simplesmente modifica-las de acordo com o nosso interesse, para agente começar a mecher nos sinais devemos é claro, entendê-los:</p>
<p>0 =&gt; Saída normal do programa.
1 =&gt; Sinal de quando se recebe um kill -HUP
2 =&gt; Interrupção forçada pelo teclado CTRL+C.
15 =&gt; Sinal de interrupção de programa quando se é kilado. (kill PID).</p>
<p>Isso é muito útil quando fazemos um programa e queremos ter certeza
que o usuário não fará a besteira de termina-lo usando CTRL+C ou se
fizer nós termos como ajeitar sua trapalhada, por exemplo:</p>
<p>$ trap &ldquo;echo THE POWER OF TRAP&rdquo; 2</p>
<p><strong>5.3 Alguns comandos: sed, cut, wc, od.</strong></p>
<p>Aqui vamos ver alguns comandos que são muito úteis quando se esta
trabalhando com arquivos, é importante domina-los para uma maior
velocidade e eficiência.</p>
<p>o&gt; sed</p>
<p>SINTAXE</p>
<p>sed <!-- raw HTML omitted --> &lt;EXPRESSÃO&gt; <!-- raw HTML omitted --></p>
<p>EXPRESSÂO</p>
<p>SUBSTITUIÇÃO</p>
<p><em>sed &rsquo;s/FRASE/NOVA/&rsquo; <!-- raw HTML omitted --></em>
Usando sed podemos substituir FRASE(strings, números, frases)
por uma NOVA palavra ou frase, vejamos um exemplo simples:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ cat file.txt
batatinha quando nasce, esparrama pelo chão.
$ sed &#39;s/esparrama/cai/&#39; file.txt
batatinha quando nasce, cai pelo chão.
</code></pre><p>EXPRESSÃO</p>
<p>EXCLUIR</p>
<p>sed &lsquo;X,Yd&rsquo; <!-- raw HTML omitted --></p>
<p>Não imprime linhas de X à Y.</p>
<p>sed &lsquo;/PALAVRA/d&rsquo; <!-- raw HTML omitted --></p>
<p>Não imprime linhas que contém PALAVRA.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ cat file.txt
Linux comanda o mundo.
Windows comanda o mundo.
Freebsd comanda o mundo.
</code></pre><p>$ sed &lsquo;2,3d&rsquo; file.txt
Linux comanda o mundo.</p>
<p>$ sed &lsquo;/Windows/d&rsquo; file.txt
Linux comanda o mundo.
Freebsd comanda o mundo.</p>
<p>EXPRESSÃO</p>
<p>NEGAR</p>
<p>sed -n &hellip;. <!-- raw HTML omitted --></p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ sed -n &#39;/Windows/!p&#39;
Linux comanda o mundo.
Freebsd comanda o mundo.
</code></pre><p>o&gt; cut</p>
<p>Serve para separar de acordo com o seu DELIMITADOR as palavras e
imprimir apenas o que é pedido.</p>
<p>SINTAXE</p>
<p>cut <!-- raw HTML omitted --> <!-- raw HTML omitted --></p>
<p>OPÇÕES</p>
<p>-d =&gt; Usado para definir qual vai ser o delimitador.
-fN =&gt; De acordo com o delimitador, a Nª palavra.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ cat /etc/passwd | cut -d&#34;:&#34; -f1
root
bin
daemon
adm
lp
sync
.......
</code></pre><p>o&gt; wc</p>
<p>Este comando serve para imprimir a quantidade de bytes, palavras
e linhas de um arquivo, é geralmente usado depois de um PIPE.</p>
<p>SINTAXE</p>
<p>wc <!-- raw HTML omitted --> <!-- raw HTML omitted --></p>
<p>OPÇÕES</p>
<p>-l =&gt; quantidade de linhas
-w =&gt; quantidade de palavras
-c =&gt; quantidade de bytes (caracteres).</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ wc -l file.txt
2 file.txt
$ wc -c file.txt
34 file.txt
</code></pre><p>o&gt; od</p>
<p>O comando od serve para imprimir um arquivo de acordo com uma
especificação dada pelo usuário, podemos imprimir um arquivo texto
com suas letras em formato hexadecimal, octal, etc.</p>
<p>SINTAXE</p>
<p>od <!-- raw HTML omitted --> <!-- raw HTML omitted --></p>
<p>OPÇÕES</p>
<p>-h =&gt; imprime letras e números em hexadecimal.
-o =&gt; imprime letras e números em octal.</p>
<pre tabindex="0"><code class="language-default" data-lang="default">$ od -h file.txt
0000000 684f 2168 7620 636f 2065 656d 6c20 7565
0000020 3a20 0a7e 7551 2065 7274 67e1 6369 5c6f
0000040 0a21
0000042
</code></pre><p>5.4 Cores no terminal.</p>
<p>Podemos sim adcionar cores para dar ênfase a alguma frase ou enfeitar nossos programas shell, usamos então uma definição especial para isso, um caracter ESC seguido de uma [ mais códigos de cores e terminando por uma barra invertida seguida de um m, &lsquo;]m&rsquo;, vejamos a lista de códigos para suas cores:</p>
<pre tabindex="0"><code class="language-default" data-lang="default">| TEXTO | FUNDO | COR               |   | CÓDIGO | SIGNIFICADO   |
+-------+-------+-------------------+   +--------+---------------+
|   30  |   40  | Preto (cinza).    |   |   0    | Desliga tudo. |
|   31  |   41  | Vermelho.         |   |   1    | Negrito.      |
|   32  |   42  | Verde.            |   |   5    | Pisca pisca.  |
|   33  |   43  | Marrom (amarelo). |   |   7    | Reverso.      |
|   34  |   44  | Azul.             |   +--------+---------------+
|   35  |   45  | Roxo.             |
|   36  |   46  | Ciano.            |   *OBS: ESC == 33 (Octal)
|   37  |   47  | Cinza (branco).   |
+-------+-------+-------------------+
</code></pre><p>$ echo -e &ldquo;33[40;31;1mSPORT RECIFE33[m&rdquo;
$ echo -e &ldquo;33[42;32;1mLOL33[m&rdquo;</p>
<p><strong>6. Arquivos de configuração.</strong></p>
<p>Estes arquivos servem para quando iniciarmos a shell, carregarmos ou
executarmos váriaveis/programas, mudarmos o prompt, adcionarmos aliases
e várias outras opções.</p>
<p>o&gt; .bashrc / .bash_profile</p>
<p>Este arquivo é executado assim que logamos na shell, podemos então
utiliza-lo para setar o prompt, adcionar aliases padrões, etc.</p>
<p>o&gt; .bash_history</p>
<p>Este é o arquivo onde ficama a história dos processados pela shell
no sistema, ele fica no diretório $HOME do usuário.</p>

  
  

  
</div>
            </main>
            
  
    <div class="article-toc ">
    <div class="toc-wrapper">
      <h4 id="contents"></h4>
      <nav id="TableOfContents"></nav>
    </div>
</div>

  

        </div>
    </body>
</html>
