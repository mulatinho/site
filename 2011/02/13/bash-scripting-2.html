<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="refresh" content="300">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Texto de 2006, adicionado ao blog.">
  <meta name="keywords" content="open source, linux, codigo aberto, desenvolvimento, programacao, software livre, free software">
  <meta name="author" content="Alexandre Mulatinho">

  <title>Bash Scripting</title>

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://alex.mulatinho.net/2011/02/13/bash-scripting-2.html">
  <link rel="alternate" type="application/rss+xml" title="Alexandre Mulatinho" href="/feed.xml">

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-107281743-1', 'auto');
  ga('send', 'pageview');

</script>
  

  
</head>


  <body>

    <header class="site-header" role="banner">

  <br/>
  <br/>

  <div class="wrapper">
    
    
    <a class="site-title" href="/">Alexandre Mulatinho</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/blog/">Blog</a>
            
          
            
            
            <a class="page-link" href="/docs/">Docs</a>
            
          
            
            
          
            
            
            <a class="page-link" href="/softwares/">Softwares</a>
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Bash Scripting</h1>
    <p class="post-meta">
      <time datetime="2011-02-13T00:00:00-03:00" itemprop="datePublished">
        
        Feb 13, 2011
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Texto de 2006, adicionado ao blog.</p>

<p>Há muito tempo eu escrevi uma introdução ao bash script e olhando ontem, resolvi fazer uma adaptação aqui no blog e colocar pra o pessoal ler, quem sabe alguém que esteja iniciando no mundo unix se interesse :-) Este texto contém uma visão introdutória sobre o que é uma shell e como a manipular, mas especificamente a Bourne-Again SHell (BASH).</p>

<p><strong>ÍNDICE</strong></p>

<p><strong>1. - A SHELL NO LINUX
1.1 - O que é uma shell?
1.2 - Principais tarefas da shell.</strong></p>

<p><strong>2. - O BÁSICO DO BÁSICO.
2.1 - Conectivos padrões e retornos lógicos.
2.2 - A matemática na shell.
2.3 - Tipos de parametros.</strong></p>

<p><strong>3. - VARIÁVEIS
3.1 - Variáveis ambiente.
3.2 - Atribuindo comandos à variáveis.</strong></p>

<p><strong>4. - ESTRUTURAS DE LOOP E CONDIÇÕES
4.1 - Usando loops.
4.2 - Fazendo condições.</strong></p>

<p><strong>5. - AVANÇANDO</strong></p>

<p><strong>5.1 - Redirecionando entrada/saída de dados.
5.2 - Usando comandos em background e adcionando interrupções.
5.3 - Alguns comandos: sed, cut, wc, od.
5.4 - Cores no terminal.</strong></p>

<p><strong>6. - ARQUIVOS DE CONFIGURAÇÃO
6.1 - .bashrc
6.2 - .bash_history</strong></p>

<p>BIBLIOGRAFIA:
Programação Shell Linux, Júlio Cezar Neves, Brasport.
The GNU Bash Reference Manual</p>

<p><a href="http://www.network-theory.co.uk/bash/manual/toc/">http://www.network-theory.co.uk/bash/manual/toc/</a></p>

<p><strong>1. A shell no Linux</strong>A shell está no Linux desde o início e serve justamente para executar os comandos com mais eficiência do que seriam executados se estivessem sem a organização que ela oferece. O Linux desde o início foi desenvolvido em partes que formam um todo utilizando um núcleo que chamamos de KERNEL, essas partes são pequenos ou grandes programas que utilizam chamadas do kernel para realizar a maioria de suas tarefas em conjunto ou separados.
Digamos que se quisessemos copiar um arquivo para outro usariamos algo como o comando cp ou se quisessemos apenas modificar seu nome usariamos o comando mv. Para que tudo fosse mais prático os seus desenvolvedores pensaram em algo que pudesse interpretar e unir com mais facilidade esses comandos/programas, foi aí que originou-se a shell com o intuito de organizar estes comandos, interpretando-os e também com uma poderosa linguagem de programação com o conjunto de seus programas. O sistema operacional UNIX e seus derivados como no nosso caso, o Linux, é composto por várias “camadas”. A mais interna de todas elas é a que chamamos de KERNEL ou núcleo, ele é responsável por interagir diretamente com o HARDWARE simplesmente fornecendo o controle total para que o resto do sistema funcione, por exemplo quando escrevemos algo em um arquivo ou mesmo quando estamos lendo, o KERNEL envia sinais para que o processador procure na trilha e no setor certo do disco onde está sendo gravado/lido certo dado que foi processado.</p>

<p>Os programas por sua vez quando são executados as vezes precisam que o usuário forneça dados como argumentos ou opções, no nosso terminal então precisamos de algo que entenda o que está sendo pedido e é finalmente aí onde entramos com a SHELL.</p>

<p><strong>1.1 O Que é uma shell?</strong></p>

<p>Pra começo de conversa, no momento em que você se loga no sistema você já está numa SHELL. A SHELL é um meio pelo qual o usuário entra com dados para o sistema fazendo com que o sistema identifique esses dados e os converta para o sistema operacional poder lê-los sem ter que resolvê-los, diminuindo assim o tempo que seria gasto se a SHELL não interpretasse esses dados e o deixasse para que o kernel também fosse resolvê-lo. Tendo em vista esses dados podemos dizer que a SHELL é uma ferramenta poderosa que usamos para interpretar nossos comandos antes de roda-los fazendo com que seja possível o uso de parametros, substituição de strings, modificação de variáveis ambiente, etc. Também vale ressaltar que a shell vem com uma linguagem poderosa, chamada shell script, que nos permite utilizar laços de condição e processamento de certos dados, principalmente os de entrada e saída.</p>

<p><strong>1.2 Principais tarefas da Shell.</strong></p>

<p>As principais tarefas da nossa shell são compreender e organizar a linha de comando que o usuário envia na entrada de dados, fazendo assim com que
os comandos executados rodem com mais performance e de um jeito muito mais estruturado, depois de feito isso a shell ordena de ESPAÇO em ESPAÇO cada comando e argumento enviado, procurando-os na variável $PATH que contém os caminhos onde o usuário em questão pode executar programas. A shell também é capaz de agir como um interpretador de linguagem estruturada, permitindo-nos fazer scripts com a mistura de comandos que o sistema nos fornece. Podemos resumir então estes processos desta forma:</p>

<p>*A shell pega os dados e os interpreta antes de serem executados.</p>

<p>*Usa variáveis ambiente como o $PATH, que nos mostra os diretórios aos quais o usuário tem acesso para execução de comandos.</p>

<p>*Processa como os dados vão sair e entrar corretamente (input/output).</p>

<p>*A nível de programação ela executa laços, condições, etc.</p>

<p><strong>2. O básico do básico.</strong></p>

<p>Este capítulo é chamado de básico do básico porque relaciona coisas bem iniciantes a nível de noções da shell no Linux, para obtermos uma visão
correta é preciso ter noção de como funciona alguns comandos do linux que estão diretamente ligados ao uso da nossa shell, por exemplo para listarmos
o conteúdo de um diretório não precisamos entrar nele para ver seus arquivos, basta que usemos o comando de listagem com o diretório como
parametro, por exemplo:</p>

<p>$ ls /home/alexandre/txtz/y0/
bash.txt  plantz.txt  provas.txt  userfile.txt
ou</p>

<p>$ cd /home/alexandre/txtz/y0
$ pwd
/home/alexandre/txtz/y0
$ ls
bash.txt  plantz.txt  provas.txt  userfile.txt
Como podemos ver isso tudo é muito básico mas é necessário ter uma idéia que estamos trabalhando com um interpretador de comandos que nos oferece além de qualidade para entender o que está sendo digitado também praticidade e velocidade. Vejamos como seria se eu quisesse me movimentar um diretório abaixo:</p>

<p>$ cd ..
$ pwd
/home/alexandre/txtz
$ ls -lh
-rw-r–r–    1 alexandr users        307k Dec 22  2003 focalinux.txt
drwxr-xr-x    2 alexandr users         200 Sep  3 12:01 y0
Vemos que descemos um diretório abaixo de onde estávamos usando o comando cd seguido de 2 pontos finais, a shell interpreta isso fazendo com que nós voltemos um diretório do orignal a qual estávamos. Uma observação interessante a se comentar é que o diretório y0 nada mais é do que um
arquivo assim como todos os diretórios do linux, a diferença é a flagzinha ‘d’ na sua permissão.</p>

<p>Outra coisa que devemos observar é que como na matemática a shell da preferência a opções que estejam entre parenteses, por exemplo:</p>

<p>$ ls txtz/y0/
bash.txt  file.txt  plantz.txt  provas.txt  userfile.txt
$ pwd
/home/alexandre
$ ( cd txtz/y0/ ; cat file.txt )
voce esta me lendo! ohh :~
$ pwd
/home/alexandre
Ué ? por que eu não fui pro diretorio txtz/y0/ ? e como eu li o arquivo file.txt se ele estava dentro desse diretório e eu ainda continuo no $HOME
CALMA! Não foi nenhuma macumba.. o que aconteceu foi que a shell deu preferência ao comando entre parenteses, executou o comando em uma shell filho e retornou a shell normal matando a shell filho. Outro tipo de forma pra mostramos como o parenteses está em preferência com a shell é usando um comando qualquer entre parenteses:</p>

<p>$ echo “A versão do meu kernel é: $(uname -r)”
A versão do meu kernel é: 2.4.26
Para saber como funciona essa interpretação de comandos nós temos que
voltar a coisas bem iniciais por isso chamamos essa parte de básico do
básico, imaginemos então:</p>

<p>$ ls
eu.txt voce.txt nos.txt vos.txt eles.txt
Temos um comando simples ‘ls’ que quando executado na shell
retorna os arquivos do diretorio em que estamos. Agora vejamos:</p>

<p>$ ls e*
eu.txt eles.txt
Digitamos novamente o ‘ls’ sendo que com um argumento, a primeira letra
‘e’ seguida de um ASTERISCO, a shell então retorna todos os arquivos do
diretório que contém a primeira letra que indicamos mais TODO O RESTO, que
é o que significa o asterisco. Vemos agora a utilidade das aspas no echo:</p>

<p>$ echo 1 2 3…    VOCE  EH ESTA  APRENDENDO  BASH
1 2 3… VOCE EH ESTA APRENDENDO BASH
$ echo “1 2 3…    VOCE  EH ESTA  APRENDENDO  BASH”
1 2 3…    VOCE  EH ESTA  APRENDENDO  BASH
OBS: Veja que a mudança ocorre na saída do texto quando usamos às aspas.</p>

<p>Resumindo, ela interpretou o comando antes de executa-lo, isso se faz
muito útil para que você as vezes não tenha que fazer vários comandos com
um objetivo só ou as vezes queira obter mais performance. Por exemplo no
caso de interagir com um ou mais comandos, deve-se usar conectivos.</p>

<p>2.1 Conectivos padrões e retornos lógicos.</p>

<p>TABELA DE CONECTIVOS                       TABELA VERDADE
+———–+———————————+   +—+—+——+
| CONECTIVO | DESCRIÇÃO                       |   | A | B |A &amp;&amp; B|
+———–+———————————+   +—+—+——+
|     &amp;&amp;    | AND (E) lógico.                 |   | 0 | 0 |  0   |
|     ||    | DOUBLE PIPE (OU) lógico.        |   | 0 | 1 |  0   |
|     |     | PIPE (OU) lógico.               |   | 1 | 0 |  0   |
+———–+———————————+   | 1 | 1 |  1   |</p>

<p>$ df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hda1             9.8G  2.9G  6.9G  29% /
/dev/hda4              14G  3.2G   10G  23% /mnt
$ echo $?
0
O duplo caracter $? (dólar,interrogação) retorna o valor do resultado do
comando digitado na entrada, fornecendo 0 se o comando retornar OK e 1 se
ele retornar com algum erro (observemos que é o inverso da tabela verdade
usada na lei de Boole). Com isso podemos usar os conectivos e colocar dois
comandos numa linha apenas, por exemplo:</p>

<p>$ cd /
$ echo “Arquivos do diretório atual ($PWD):” &amp;&amp; ls
Arquivos do diretório atual (/):
bin  boot  dev  etc  home  lib  mnt  opt  proc  root  sbin  tmp  usr  var
*OBS: Como o resultado do comando echo e do ls são 0 (e na tabela verdade
da shell o 0 representa LIGADO), indicando que eles retornaram VERDADEIRO
os dois comandos são colocados na tela. O $PWD é uma variável do sistema
que será explicada depois ;)</p>

<p>Então já podemos dizer que a tabela VERDADE da nossa shell ficaria da
forma inversa da tabela original da lei de Boole.</p>

<p>TABELA VERDADE DE EXECUÇÃO NA SHELL</p>

<p>+—+—+——+
| A | B | A&amp;&amp;B |          RETORNO:
+—+—+——+          ——–
| 0 | 0 |  0   |          0 = OK.
| 0 | 1 |  1   |          1 = ERRO.
| 1 | 0 |  1   |
| 1 | 1 |  1   |
+—+—+——+
Ou seja, os dois comandos só seriam impressos na tela juntos se ambos os
termos fossem 0 quanto ao seu resultado. Agora vejamos se no primeiro
argumento o resultado fosse maior que ou igual a 1, e o próximo fosse 0
usando o AND condicional ficaria:</p>

<p>$ ls /root &amp;&amp; echo “Fim do /root”
ls: /root: Permission denied
$ echo $?
1
*OBS: O 1° argumento retorna um numero diferente de 0 fazendo com que o
2° comando nao seja executado porque de acordo com a tabela verdade
do AND condicional o 2° comando só executado se houvesse uma verdade
lógica ou um retorno 0;.</p>

<p>Temos:</p>

<p>$ ls /root
ls: /root: Permission denied
$ echo $?
1</p>

<p>$ echo “Fim do /root”
Fim do /root
$ echo $?
0
Então:</p>

<p>!(1 &amp;&amp; 0) =&gt;; 1 (ERRO/DESLIGADO)
Já no caso do PIPE (|), a prioridade dos argumentos sempre estão do lado
direito(ou 2° argumento) é muito útil quando estamos lendo algo no console
quando o texto é muito grande e precisamos realizar pausas pra leitura:</p>

<p>$ cat /usr/doc/Linux-HOWTOs/Bash-Prompt-HOWTO | grep PS1
O comando cat é executado fazendo com que todo o arquivo seja impresso na tela embora com uma diferença, todo o texto é enviado para o comando grep, que por sua vez procura por strings no arquivo e entrada retornando apenas as linhas que contenham o argumento passado no comando ‘grep’ ;]</p>

<p><strong>2.2 A matemática da shell.</strong></p>

<p>Temos várias formas para realizarmos calculos matemáticos na shell,
podemos simplesmente usar o comando ‘expr’ ou usar cálculos entre
parenteses com as definições de operadores da shell.</p>

<p>TABELA DE OPERADORES
+——-+———————————————–+
| VALOR | SIGNIFICADO                                   |
+——-+———————————————–+
|   +   | Como na matemática, serve para somar números. |
|   -   | Também como na matemática, subtrair.          |
|   /   | Este é o operador para divisão de números.    |
|   *   | Operador de multiplicação.                    |
|   %   | Resto de uma divisão.                         |
| == != | Igual e diferente.                            |
| &lt;= &gt;= | Menor igual que, maior igual que.             |
+——-+———————————————–+
Podemos realizar operações usando o comando expr mais os números e que
tipo de operadores queremos para realizar cálculos, ou simplesmente usar o
echo $((CALCULO MATEMATICO)), onde dentro desses DOIS parenteses, faremos
o cálculo para ser armazenado ou impresso na tela. Exemplos:</p>

<p>Fazer a soma de 4 + 5:</p>

<p>$ expr 4 + 5
9
A média aritmética de 20+15+10:</p>

<p>$ echo $(( (20+15+10) / 3 ))
15
Multiplicar 3 por 5:</p>

<p>$ expr 3 * 5
expr: syntax error
Ué!? O que houve de errado? bom, relembrando o início a shell interpreta os comandos antes de executa-los, ela entendeu o ASTERISCO como usamos anteriormente significando QUALQUER COISA, só que isso numa operação matemática não faz sentido. O que fazer então? temos que proteger o asterisco da shell pra dar prioridade ao operador e não a interpretação
que a shell faz do asterisco normal.</p>

<p>Novamente, protegendo o asterisco, multiplicando 3 por 5:</p>

<p>$ expr 3 * 5
15
Há também outra forma de fazermos cálculos, usando a cálculadora padrão do GNU a bc. Como vimos, usando o PIPE odemos jogar uma informação no 2° argumento de um comando:</p>

<p>$ echo “(4 * 27) + 21” | bc
129
Usamos às aspas para proteger o parenteses da shell e jogamos a operação
na calculadora bc que nos retorna o resultado rapidamente.</p>

<p>2.3 Tipos de parâmetros.</p>

<p>O uso de parametros é quase constante em uma linha de comando de uma
pessoa que esteja acostumada à shell, eles tornam tudo mais fácil e as
vezes se fazem extremamente necessários.</p>

<p>o&gt; parametro de substituição de comando</p>

<p>para a shell saber onde executar os comandos é necessário uma forma de
procura por programas para executar no sistema, a variável $PATH indica
onde o usuário em questão verá os diretorios separados por ‘:’ do
sistema aos quais ele obterá acesso à comandos.</p>

<p>podemos utilizar um parametro para executar comandos na shell fazendo
com que seu output saia na tela ou seja armazenado em alguma variável,
a shell bash vai entender o que estiver entre os parenteses como um
comando de algum diretório do $PATH.</p>

<p>SINTAXE</p>

<p>$(COMANDO) =&gt; Abre uma subshell e executa o comando retornando a
shell pai e saindo da subshell.</p>

<p>ou</p>

<p><code class="highlighter-rouge">comando</code> =&gt; Executa um comando normal do sistema.</p>

<p>$ echo -e “todays fortune:n $(fortune)”
todays fortune:
“All flesh is grass”
– Isiah
Smoke a friend today.</p>

<p>$ SYSTEM=<code class="highlighter-rouge">uname -s</code>
$ echo “Sistema: $SYSTEM”
Sistema: Linux
voce pediu pra a shell imprimir uma frase, seguida de um comando
‘fortune’ que faz parte de um pacote chamado bsdgames, ele é bem
interessante, é composto de milhares de frases e pensamentos de
filósofos, autores de livros, etc. já no segundo exemplo usamos uma
variável SYSTEM para armazenar o retorno do comando ‘uname -s’ depois
imprimimos na tela.</p>

<p>o&gt; parametros com chaves</p>

<p>as vezes queremos nos referir a um nome de arquivo em vários tipos de
extensão, ou fazer coisas do tipo, para isso podemos ao inves de ter
que escrever toda a linha de comando repetidamente usamos as chaves.</p>

<p>$ echo m{a,e,o}ngo          ou         $ ls *.{bz2,txt}
mango mengo mongo                      IAO-paper.txt focalinux.txt
gcc-3.3.tar.bz2 retlib.txt
evitamos ter que fazer repetições na linha de comando colocando as
sequencias necessarias entre chaves.</p>

<p>o&gt; outros parametros</p>

<p>podemos trocar strings de um parametro, declaramos ele desta forma:
${PARAMETRO/STRING/NEWSTRING} , onde STRING é a ocorrência que você
deseja modificar e o NEWSTRING é a nova string que vai ficar.</p>

<p>$ STR=”estou aprendendo a errar”
$ echo ${STR/errar/viver}
estou aprendendo a viver
ou se quisessemos ver o tamanho de caracteres de uma string, fariamos
assim ${#STRING}, onde STRING seria a variavel ou palavra/frase.</p>

<p>$ echo $STR
estou aprendendo a errar
$ echo ${#STR}
24
para pegarmos um argumento da linha de comando usamos o carácter
dólar seguido da ordem do seu argumento, exemplo:</p>

<p>$ ./comando arg1 arg2 arg3
$1 -&gt; arg1
$2 -&gt; arg2
$3 -&gt; arg2</p>
<ol>
  <li>Variáveis.</li>
</ol>

<p>Uma coisa muito útil na shell é a possibilidade de armazenamento de
dados na memória, fazendo isso podemos atribuir à variaveis saídas de
comandos, calculos aritméticos e strings. Para setar uma variável na
shell basta fazer:</p>

<p>$ A=1
$ B=HELLO
$ C=”HELLO WORLD”</p>

<p>$ echo $A $B $C
1 HELLO HELLO WORLD
Veja que dessa vez não usamos o DÓLAR para setar a variável A,B,C esse
dólar só vai ser colocado quando quisermos que a shell retorne o valor
da variável. Para remover a variável do sistema é só fazer:</p>

<p>$ unset C
$ echo $C
3.1 Variáveis ambiente.</p>

<p>Há uma série de variáveis padrões definidas pela SHELL quando você se
loga nela, estas servem para organizar de forma mais eficiente tudo que
o usuário tem acesso, pode fazer e quer saber. Vamos ver algumas delas:</p>

<p>$HOME =&gt; Indica o diretório raiz do usuário que esta logado na shell.
$PATH =&gt; Diretórios aos quais o usuário tem acesso à comandos.
$PWD =&gt; Diretório onde o usuário se encontra.
$USER =&gt; Usuário logado na shell.</p>

<p>Para vermos todas elas usamos o comando ‘export’ que serve também para
setar as variáveis ambiente na shell. Para ver todas:</p>

<p><strong>$ export</strong></p>

<p>…………………….</p>

<p>Para setar:</p>

<p>$ export VAR=”Conteúdo”
$ echo $VAR
Conteúdo
3.2 Atribuindo comandos à variáveis.</p>

<p>Podemos utilizar as variáveis também para armazenar saída de comandos
do sistema, para isso colocamos o comando entre crases, vejamos exemplos:</p>

<p>$ cd txtz/y0/
$ pwd
/home/alexandre/txtz/y0
$ var=<code class="highlighter-rouge">ls</code>
$ echo $var
bash.txt file.txt plantz.txt provas.txt slides.txt userfile.txt
Entramos no diretório e setamos uma variável ‘var’ com o valor da saída
do comano ‘ls’, depois imprimimos o valor com o comando echo.</p>

<p>$ proc=<code class="highlighter-rouge">cat /proc/cpuinfo | grep "model name" | cut -d" " -f4-10</code>
$ echo “PROCESSADOR: $proc”
PROCESSADOR: Athlon(tm) XP 1700+</p>

<p><strong>4. Estrutura de loops e condições.</strong></p>

<p>Podemos elaborar processos repetidas vezes de acordo com a condição que
desejarmos, usando as estruturas de loop e condições começamos a falar de
shell script que nada mais é do que uma forma estruturada de organizar os
comandos do sistema utilizando tudo que aprendemos em conjunto(variáveis,
comandos, retornos de comandos, etc).
Há diferença entre eles é que os loops executam uma certa sequencia de
comandos digitados pelo programador até que aconteça algo que será
processado e de acordo com o tipo de loop, terminado ou continuado,
enquanto as condições esperam que o programa receba algo e de acordo com
um teste que foi previsto pelo programador anteriormente execute um bloco
de códigos ou não.
Para setar um arquivo como shell script deve-se coloca-lo com uma
permissão de execução, fazendo:</p>

<p>$ chmod +x arquivo
$ ./arquivo
Tendo em vista isto, temos também que entender que no shell script os
operadores para condições matemáticas tambem mudam, exemplo:</p>

<p>| OPERADOR | SIGNIFICADO                                 |
+———-+———————————————+
|   -lt    | less than (menor que).                      |
|   -le    | less or equal than (menor ou igual que).    |
|   -gt    | greater than (maior que).                   |
|   -ge    | greater or equal than (maior ou igual que). |
|   -eq    | equal than (igual que).                     |
|   -ne    | not equal (diferente de).                   |
+———-+———————————————+
Também é bom lembrar que num arquivo shell script, a primeira linha
deverá sempre ser a declaração da shell em que estamos programando:</p>

<p>#!/bin/bash</p>

<p><strong>4.1 Usando loops.</strong></p>

<p>Os loops servem entre outras coisas para executar um bloco de códigos
até que um teste seja atingido, vejamos alguns tipos de loop:</p>

<p>o&gt; until</p>

<p>SINTAXE</p>

<p>until [ ‘TESTE’ ] ; do
CÓDIGO….
done
O comando until serve para executar um laço até o seu TESTE retorne
um valor diferente diferente de 0 (ou seja, até que o teste seja falso)</p>

<p>#!/bin/bash
IN=10</p>

<p>until [ $IN -lt 4 ] ; do
echo “LOOP: $IN”
IN=<code class="highlighter-rouge">expr $IN - 2</code>
done</p>

<p>$ ./until
LOOP REVERSO: 10
LOOP REVERSO: 8
LOOP REVERSO: 6
LOOP REVERSO: 4
o&gt; while</p>

<p>SINTAXE</p>

<p>while [ ‘TESTE’ ] ; do
CÓDIGO…
done
Fazendo o inverso do until, o comando while executa o CÓDIGO até que
o retorno de seu TESTE seja igual a 0 (ou seja verdadeiro), exemplo:</p>

<p>#!/bin/bash
IN=0</p>

<p>while [ $IN -lt 4 ] ; do
echo “LOOP: $IN”
IN=<code class="highlighter-rouge">expr $IN + 1</code>
done</p>

<p>$ ./while
LOOP: 0
LOOP: 1
LOOP: 2
LOOP: 3
o&gt; for</p>

<p>SINTAXE</p>

<p>for (( expr1 ; expr2; expr3 )) ; do
CÓDIGO…
done
Onde temos o primeiro modo de utilizar o for na shell, o expr1 é um valor que será atribuido à uma variável, o expr2 é um teste que será feito até que seu resultado seja verdadeiro, fazendo com que o bloco de código seja executado repitidamente e expr3 será o que será feito quando o teste for verdadeiro, poucos usam o for desta forma embora na minha opnião seja mais eficiente. Por exemplo:</p>

<p>#!/bin/bash
for (( i=0 ; i&lt;5 ; i++ )); do
echo “loop: $i”
done</p>

<p>$ ./for
loop: 0
loop: 1
loop: 2
loop: 3
loop: 4
4.2 Fazendo condições.</p>

<p>É necessário fazer condições quando recebemos algo da entrada de um
usuário e queremos realizar um TESTE com esses dados para ver qual rumo
o programa deve tomar. Vamos usar dois tipos de comandos básicos para
execução de condições, são eles:</p>

<p>o&gt; if-then-else</p>

<p>SINTAXE</p>

<p>if [ ‘TESTE’ ] ; then
CÓDIGO…
fi
Executa o TESTE, se ele for verdadeiro executa o bloco de CÓDIGO senão sai sem executar nada dentro do if.</p>

<p>if [ ‘TESTE’ ] ; then
CÓDIGO…
elif [ ‘TESTEDOIS’ ] ; then
CÓDIGO DOIS…
fi
Executa o TESTE, aciona o bloco de CÓDIGO se o resultado do teste for verdadeiro.. depois executa o TESTEDOIS e se for verdadeiro ele executa o bloco de CÓDIGO DOIS.</p>

<p>if [ ‘TESTE’ ] ; then
CÓDIGO…
else
CÓDIGO DOIS…
then
Aqui ele executa o TESTE, entra no bloco de CÓDIGO se o resultado
do teste for verdadeiro, senão ele entre no bloco de CÓDIGO DOIS.</p>

<p>#!/bin/bash
IN=$1</p>

<p>if [ “$1” == “Mulher” ] ; then
echo “Olá senhorita :)~”
elif [ “$1” == “Homem” ] ; then
echo “Como vai meu bom homem?”
else
echo “Escolha sua opção sexual rapaz!”
fi</p>

<p>$ ./ifthenelse
Escolha sua opção sexual rapaz!
$ ./ifthenelse Homem
Como vai meu bom homem?
$ ./ifthenelse Mulher
Ola senhorita :)~
o&gt; case</p>

<p>SINTAXE</p>

<p>case ARG in
PS1)
CÓDIGO
;;</p>

<p>PS2)
CÓDIGO DOIS
;;
esac
Aqui o teste ocorre em cima de ARG, o case explode várias possíveis alternativas que podem ser PS1, PS2, PS3, …, PSN. Uma boa função do case é poder fazer essas possibilidades usando meta-caracteres.</p>

<p>#!/bin/bash
IN=$1</p>

<p>case $IN in
[a-c])
echo “Tu és homem!”
;;
[d-f])
echo “Tu és mulher!”
;;
[0-9])
echo “Tá confuso?”
;;
esac</p>

<p>$ ./case b
Tu és homem!
$ ./case 3
Tá confuso?</p>
<ol>
  <li>Avançando.</li>
</ol>

<p>Nesta parte vamos começar a complicar mais um pouquinho pra descomplicar bem muito, hã? é isso mesmo, aqui vamos mostrar alguns comandos que a maioria nem chega perto mas que são úteis demais para um shell scripter.</p>

<p><strong>5.1 Redirecionando entrada/saída de dados.</strong></p>

<p>Podemos direcionar como os dados irão entrar e como irão sair em nossa shell usando operadores, para começarmos a fazer isso devemos lembrar os 3 tipos padrões de entrada/saída de dados, são eles:</p>

<p>(0 ou STDIN) =&gt; Standard Input (Entrada Padrão).
(1 ou STDOUT) =&gt; Standard Output (Saída Padrão).
(2 ou STDERR) =&gt; Standard Error (Saída de erro padrão).</p>

<p>Tendo em mente isso, usamos operadores para o redirecionamento que são parecidos com os símbolos da matemática:</p>

<p>| OP | SIGNIFICADO |
+—-+—————————————————————-+
| N&gt; | Onde N, é o valor da saída de dados (1 ou 2), fazendo com que |
| | o redirecionamento da saída seja feito há direita do operador. |
| &gt; | Envia os dados para arquivo, criando-o caso não existe ou |
| | apagando seu conteúdo anterior e adcionando novo, caso exista. |
| » | Aqui há o redirecionamento de dados para o FINAL do arquivo |
| | caso exista, ou uma criação de arquivo, caso não exista. |
| &lt; | Setamos na shell que a entrada padrão não irá vir do teclado |
| | e sim do arquivo em questão. |
| « | Indicamos um LABEL para o começo de uma linha fazendo com que |
| | a linha só termine quando houver a proxima ocorrência do LABEL |
+—-+—————————————————————-+</p>

<p>$ echo “Ohh! voce me leu :~” &gt; file.txt
$ cat file.txt
Ohh! voce me leu :~</p>

<p>$ echo “Que trágico!” » file.txt
$ cat file.txt
Ohh! voce me leu :~
Que trágico!</p>

<p>$ tr e i &lt; file.txt
Ohh! voci mi liu :~
Qui trágico!</p>

<p>$ mount /dev/cdrom /mnt/cdrom 2&gt; error.txt
$ cat error.txt
mount: only root can do that</p>

<p><strong>5.2 Usando comandos em background e adcionando interrupções</strong></p>

<p>Podemos rodar comandos em modo background., que significaria mais ou
menos que executamos um comando deixando-o numa file de espera, então
ele em alguns programas que precisam de entrada de dados só irá
executar suas funções quando agente o chamar no sistema.</p>

<p>$ vim file.txt &amp;
[1] 22956
Î   Î
`—|——– 1 = First Job (Primeiro trabalho.)
‘— 22956 = PID (Process ID).
Vêmos que ele carregou o programa numa subshell, mas não executou a sua função que era de editar o arquivo, para fazermos isso, digitamos</p>

<p>$ fg 1</p>

<p>E então o ID do processo em background sairá da subshell e virá para nossa shell principal, podemos fazer isso várias vezes. Outra coisa muito útil é que podemos adcionar interrupções ou simplesmente modifica-las de acordo com o nosso interesse, para agente começar a mecher nos sinais devemos é claro, entendê-los:</p>

<p>0 =&gt; Saída normal do programa.
1 =&gt; Sinal de quando se recebe um kill -HUP
2 =&gt; Interrupção forçada pelo teclado CTRL+C.
15 =&gt; Sinal de interrupção de programa quando se é kilado. (kill PID).</p>

<p>Isso é muito útil quando fazemos um programa e queremos ter certeza
que o usuário não fará a besteira de termina-lo usando CTRL+C ou se
fizer nós termos como ajeitar sua trapalhada, por exemplo:</p>

<p>$ trap “echo THE POWER OF TRAP” 2</p>

<p><strong>5.3 Alguns comandos: sed, cut, wc, od.</strong></p>

<p>Aqui vamos ver alguns comandos que são muito úteis quando se esta
trabalhando com arquivos, é importante domina-los para uma maior
velocidade e eficiência.</p>

<p>o&gt; sed</p>

<p>SINTAXE</p>

<p>sed <OPCAO> <EXPRESSÃO> <ARQUIVO></ARQUIVO></EXPRESSÃO></OPCAO></p>

<p>EXPRESSÂO</p>

<p>SUBSTITUIÇÃO</p>

<p>sed ‘s/FRASE/NOVA/’ <ARQUIVO>
Usando sed podemos substituir FRASE(strings, números, frases)
por uma NOVA palavra ou frase, vejamos um exemplo simples:</ARQUIVO></p>

<p>$ cat file.txt
batatinha quando nasce, esparrama pelo chão.
$ sed ‘s/esparrama/cai/’ file.txt
batatinha quando nasce, cai pelo chão.
EXPRESSÃO</p>

<p>EXCLUIR</p>

<p>sed ‘X,Yd’ <ARQUIVO></ARQUIVO></p>

<p>Não imprime linhas de X à Y.</p>

<p>sed ‘/PALAVRA/d’ <ARQUIVO></ARQUIVO></p>

<p>Não imprime linhas que contém PALAVRA.</p>

<p>$ cat file.txt
Linux comanda o mundo.
Windows comanda o mundo.
Freebsd comanda o mundo.
$ sed ‘2,3d’ file.txt
Linux comanda o mundo.</p>

<p>$ sed ‘/Windows/d’ file.txt
Linux comanda o mundo.
Freebsd comanda o mundo.</p>

<p>EXPRESSÃO</p>

<p>NEGAR</p>

<p>sed -n …. <ARQUIVO></ARQUIVO></p>

<p>$ sed -n ‘/Windows/!p’
Linux comanda o mundo.
Freebsd comanda o mundo.
o&gt; cut</p>

<p>Serve para separar de acordo com o seu DELIMITADOR as palavras e
imprimir apenas o que é pedido.</p>

<p>SINTAXE</p>

<p>cut <option> <ARQUIVO></ARQUIVO></option></p>

<p>OPÇÕES</p>

<p>-d =&gt; Usado para definir qual vai ser o delimitador.
-fN =&gt; De acordo com o delimitador, a Nª palavra.</p>

<p>$ cat /etc/passwd | cut -d”:” -f1
root
bin
daemon
adm
lp
sync
…….
o&gt; wc</p>

<p>Este comando serve para imprimir a quantidade de bytes, palavras
e linhas de um arquivo, é geralmente usado depois de um PIPE.</p>

<p>SINTAXE</p>

<p>wc <OPCOES> <ARQUIVO></ARQUIVO></OPCOES></p>

<p>OPÇÕES</p>

<p>-l =&gt; quantidade de linhas
-w =&gt; quantidade de palavras
-c =&gt; quantidade de bytes (caracteres).</p>

<p>$ wc -l file.txt
2 file.txt
$ wc -c file.txt
34 file.txt
o&gt; od</p>

<p>O comando od serve para imprimir um arquivo de acordo com uma
especificação dada pelo usuário, podemos imprimir um arquivo texto
com suas letras em formato hexadecimal, octal, etc.</p>

<p>SINTAXE</p>

<p>od <OPCOES> <ARQUIVO></ARQUIVO></OPCOES></p>

<p>OPÇÕES</p>

<p>-h =&gt; imprime letras e números em hexadecimal.
-o =&gt; imprime letras e números em octal.</p>

<p>$ od -h file.txt
0000000 684f 2168 7620 636f 2065 656d 6c20 7565
0000020 3a20 0a7e 7551 2065 7274 67e1 6369 5c6f
0000040 0a21
0000042
5.4 Cores no terminal.</p>

<p>Podemos sim adcionar cores para dar ênfase a alguma frase ou enfeitar nossos programas shell, usamos então uma definição especial para isso, um caracter ESC seguido de uma [ mais códigos de cores e terminando por uma barra invertida seguida de um m, ‘]m’, vejamos a lista de códigos para suas cores:</p>

<p>| TEXTO | FUNDO | COR               |   | CÓDIGO | SIGNIFICADO   |
+——-+——-+——————-+   +——–+—————+
|   30  |   40  | Preto (cinza).    |   |   0    | Desliga tudo. |
|   31  |   41  | Vermelho.         |   |   1    | Negrito.      |
|   32  |   42  | Verde.            |   |   5    | Pisca pisca.  |
|   33  |   43  | Marrom (amarelo). |   |   7    | Reverso.      |
|   34  |   44  | Azul.             |   +——–+—————+
|   35  |   45  | Roxo.             |
|   36  |   46  | Ciano.            |   *OBS: ESC == 33 (Octal)
|   37  |   47  | Cinza (branco).   |
+——-+——-+——————-+
$ echo -e “33[40;31;1mSPORT RECIFE33[m”
$ echo -e “33[42;32;1mLOL33[m”</p>

<p><strong>6. Arquivos de configuração.</strong></p>

<p>Estes arquivos servem para quando iniciarmos a shell, carregarmos ou
executarmos váriaveis/programas, mudarmos o prompt, adcionarmos aliases
e várias outras opções.</p>

<p>o&gt; .bashrc / .bash_profile</p>

<p>Este arquivo é executado assim que logamos na shell, podemos então
utiliza-lo para setar o prompt, adcionar aliases padrões, etc.</p>

<p>o&gt; .bash_history</p>

<p>Este é o arquivo onde ficama a história dos processados pela shell
no sistema, ele fica no diretório $HOME do usuário.</p>

  </div>

  
    
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://alex.mulatinho.net/2011/02/13/bash-scripting-2.html';
      this.page.identifier = 'http://alex.mulatinho.net/2011/02/13/bash-scripting-2.html';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://mulatinho.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

      <p>A blog about linux, open source, development and the life of an software engineer ;)</p>

      <br/>
      <br/>

      <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- mulato-blog -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-5138819533079914"
     data-ad-slot="8675679252"
     data-ad-format="auto"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

      
    </div>

  </div>

</footer>


  </body>

</html>
